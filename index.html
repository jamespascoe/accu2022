<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>How to Use C++20 Coroutines for Networking</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>

        <section data-menu-title="Coroutines for Networking">
          <h2>How to Use C++20 Coroutines<br>for Networking</h2>
          <p>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2022">http://jamespascoe.github.io/accu2022</a><br>
              <a href="https://github.com/jamespascoe/accu2022-example-code.git">https://github.com/jamespascoe/accu2022-example-code.git</a>
            </small>
        </section>
        <section data-menu-title="Poll: Coroutine Familiarity">
          <h3 style="color:yellow">How Familiar are you with Coroutines?</h3>
            <ol>
              <span class="fragment"><li>I am a coroutine expert</li></span>
              <span class="fragment"><li>I have a strong grasp but need to fill in some details</li></span>
              <span class="fragment"><li>I have some understanding but want to learn more</li></span>
              <span class="fragment"><li>I am just starting to learn about them</li></span>
            </ol>
        </section>
        <section>
          <h2>Overview</h2>
          <span class="fragment" style="color:yellow">Demystify Using C++20 Coroutines for Networking</span><br>
          <span class="fragment" style="color:yellow">Emphasis on practical examples and code</span>
          <p>
          <ul>
            <span class="fragment"><li>Coroutines: fundamentals, benefits and usage</li></span>
            <span class="fragment">
              <ul>
                <li><a href="https://www.lua.org/versions.html#5.4">Lua 5.4.4</a><span class="fragment"> and <a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20</a></span></li>
              </ul>
            </span>
            <span class="fragment"><li>How to Write Networking Code Using Coroutines</li></span>
            <ul>
              <span class="fragment"><li><a href="https://github.com/jamespascoe/CoChat.git">CoChat</a>: a coroutine based chat program</li></span>
              <span class="fragment"><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/cpp20_coroutines.html">Boost Asio (1.78)</a></li></span>
            </ul>
            <span class="fragment"><li>C++23: the future of Coroutines</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code.git">Example Code: Tools & Build</a></h2>
            <ul>
              <span class="fragment"><li>C++ examples all compile with <a href="https://gcc.gnu.org/gcc-11/changes.html">GCC 11.2</a>:</li></span>
              <span class="fragment"><ul><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio.html">Boost Asio 1.78.0</a> (also works with 1.76.0)</li></ul></span>
              <span class="fragment"><li>Lua examples run with <a href="https://www.lua.org/download.html">Lua 5.4.4</a>:</li></span>
              <span class="fragment"><ul><li>Requires <code>luaposix</code> and <code>luasocket</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luaposix</code></li></ul></span>
              <span class="fragment"><ul><li><code>sudo luarocks install luasocket</code></li></ul></span>
              <span class="fragment"><li>Tested on Linux Mint 19 and Mac OS X (<font size="6">Big Sur</font>, <font size="6">Mojave</font>)</li></span>
            </ul>
        </section>

      <section>
        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Fundamentals</h1>
        </section>

        <section>
          <h2>Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution (returns to the caller)</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <section data-menu-title="Echo Server Capture">
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/echo_server">Echo Server Build & Run</a></h2>
          <video data-autoplay src="media/echo-server-terminal-capture-1080.mov"></video>
        </section>

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Blocking Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|21|23|25-40|">
//
// echo_server_blocking.cpp
//

#include &ltboost/asio.hpp&gt
#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::io_context;
using boost::asio::ip::tcp;
using boost::system::error_code;

static const int buf_len = 1000;

int main() {
  try {
    io_context ctx;

    tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

    for (;;) {
      tcp::socket peer_socket(ctx);
      acceptor.accept(peer_socket);

      std::array&ltchar, buf_len&gt buf;

      for (;;) {
        error_code error;
        std::size_t len =
            peer_socket.read_some(buffer(buf), error);
        if (error == boost::asio::error::eof)
          break;

        write(peer_socket, buffer(buf, len));
      }
    }
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt "\n";
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Asynchronous Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|89-105|96-98|101|72-87|47-70|31-45|">
//
// echo_server_async.cpp
//

#include &ltboost/asio.hpp&gt

#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::io_context;
using boost::asio::ip::tcp;
using boost::system::error_code;

static const int buf_len = 1000;

void accept_handler(error_code const &error,
                    tcp::socket &peer_socket,
                    std::array&ltchar, buf_len&gt &buf,
                    tcp::acceptor &acceptor);

void read_handler(error_code const &error,
                  std::size_t bytes_transferred,
                  tcp::socket &peer_socket,
                  std::array&ltchar, buf_len&gt &buf,
                  tcp::acceptor &acceptor);

void write_handler(error_code const &error, std::size_t length,
                   tcp::socket &peer_socket,
                   std::array&ltchar, buf_len&gt &buf,
                   tcp::acceptor &acceptor) {
  if (!error) {
    peer_socket.async_read_some(
        buffer(buf, length), [&](error_code const &error,
                                 std::size_t bytes_transferred) {
          read_handler(error, bytes_transferred, peer_socket, buf,
                       acceptor);
        });
  } else
    std::cerr &lt&lt "Write handler error: " &lt&lt error.message()
              &lt&lt std::endl;
}

void read_handler(error_code const &error,
                  std::size_t bytes_transferred,
                  tcp::socket &peer_socket,
                  std::array&ltchar, buf_len&gt &buf,
                  tcp::acceptor &acceptor) {
  if (!error) {
    async_write(peer_socket, buffer(buf, bytes_transferred),
                [&](error_code const &error, std::size_t length) {
                  write_handler(error, length, peer_socket, buf,
                                acceptor);
                });
  } else {
    if (error == boost::asio::error::eof) {
      peer_socket.close();

      acceptor.async_accept(
          peer_socket, [&](error_code const &error) {
            accept_handler(error, peer_socket, buf, acceptor);
          });
    } else
      std::cerr &lt&lt "Read handler error: " &lt&lt error.message()
                &lt&lt std::endl;
  }
}

void accept_handler(error_code const &error,
                    tcp::socket &peer_socket,
                    std::array&ltchar, buf_len&gt &buf,
                    tcp::acceptor &acceptor) {

  if (!error) {
    peer_socket.async_read_some(
        buffer(buf, buf_len), [&](error_code const &error,
                                  std::size_t bytes_transferred) {
          read_handler(error, bytes_transferred, peer_socket, buf,
                       acceptor);
        });
  } else
    std::cerr &lt&lt "Accept handler error: " &lt&lt error.message()
              &lt&lt std::endl;
}

int main() {
  io_context ctx;
  tcp::socket peer_socket(ctx);
  tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

  std::array&ltchar, buf_len&gt buf;

  acceptor.async_accept(peer_socket, [&](error_code const &error) {
    accept_handler(error, peer_socket, buf, acceptor);
  });

  try {
    ctx.run();
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt "\n";
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Coroutine Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|43-57|50-51|53|22-41|27|30-31|35-36|">
//
// echo_server_coroutine.cpp
//

#include &ltboost/asio.hpp&gt
#include &ltboost/asio/experimental/as_tuple.hpp&gt

#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::detached;
using boost::asio::io_context;
using boost::asio::use_awaitable;
using boost::asio::experimental::as_tuple;
using boost::asio::ip::tcp;
using boost::system::error_code;

boost::asio::awaitable&ltvoid&gt echo(tcp::socket peer_socket,
                                  tcp::acceptor acceptor) {
  std::array&ltchar, 1000&gt buf;

  for (;;) {
    co_await acceptor.async_accept(peer_socket, use_awaitable);

    for (;;) {
      auto [error, len] = co_await peer_socket.async_read_some(
          buffer(buf), as_tuple(use_awaitable));
      if (error == boost::asio::error::eof)
        break;

      co_await async_write(peer_socket, buffer(buf, len),
                           use_awaitable);
    }

    peer_socket.close();
  }
}

int main() {
  try {
    io_context ctx;

    tcp::socket socket(ctx);
    tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

    co_spawn(ctx, echo(std::move(socket), std::move(acceptor)),
             detached);

    ctx.run();
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt std::endl;
  }
}
          </code></pre>
        </section>

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>C++20 Coroutines</h1>
        </section>

        <section data-menu-title="Coroutines in C++20">
          <h2><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine Support in C++20</a></h2>
            <ul>
              <span class="fragment"><li>Three new keywords: <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a></li></span>
              <span class="fragment"><li>New types:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle"><code>coroutine_handle&ltP&gt</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits"><code>coroutine_traits&ltTs...&gt</code></a></li></span>
              </ul>
              <span class="fragment"><li>Trivial awaitables:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_always"><code>std::suspend_always</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_never"><code>std::suspend_never</code></a></li></span>
              </ul>
            </ul>
        </section>

        <section>
          <h2>Tips for Learning</h2>
            <ul>
              <span class="fragment"><li>Principally for library development (not user-code)</li></span>
              <span class="fragment"><li>Libraries with coroutine support:</li></span>
              <ul>
                <span class="fragment"><li>Boost Asio:</li>
                  <ul>
                    <li>(first in <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/overview/core/coroutines_ts.html">1.67.0</a>, 'C++20 Support' in <a href="https://www.boost.org/doc/libs/1_77_0/doc/html/boost_asio/overview/core/cpp20_coroutines.html">1.77.0</a>)</li>
                  </ul>
                </span>
                <span class="fragment"><li>Lewis Baker's <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a></li></span>
              </ul>
              <span class="fragment"><li><span style="color:yellow">References to 'promise' and 'future' are not <code>std::promise</code> and <code>std::future</code>!</span></li></span>
            </ul>
        </section>

        <section id="key-references">
          <h2>Key References</h2>
            <ul>
              <span class="fragment"><li><a href="https://lewissbaker.github.io/">Lewis Baker:</a></li></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine Theory</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Understanding operator co_await</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Understanding the promise type</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer">Understanding Symmetric Transfer</a></li></ul></span>
              <span class="fragment"><li><a href="https://www.scs.stanford.edu/~dm">Dave Mazière:</a></li></span>
              <span class="fragment"><ul><li><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">My tutorial and take on C++20 coroutines</a></li></ul></span>
              <span class="fragment"><li><a href="https://wg21.link/n4775">Gor Nishanov:</a></li></span>
              <span class="fragment"><ul><li><a href="https://wg21.link/n4775">C++ Extensions for Coroutines (N4775)</a></li></ul></span>
            </ul>
        </section>

        <section>
          <h2>Tutorial Overview</h2>
            <ul>
              <span class="fragment"><li>Goal: implement a 'chat' program using coroutines</li></span>
              <span class="fragment"><li>Prototype in <a href="https://www.lua.org/pil/9.1.html">Lua 5.4.4</a></span><span class="fragment"> (and then in C++)</span></li></span>
              <span class="fragment"><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">C++20</a> coroutines:</li></span>
              <ul>
                <span class="fragment">
                  <li>
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>,
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a> and
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a>
                  </li>
                </span>
                <span class="fragment"><li>Return objects, promises, awaitables and traits</li></span>
              </ul>
              <span class="fragment"><li>Implement 'chat' in C++ (using <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio.html">Boost Asio 1.78</a>)</li></span>
            </ul>
        </section>

        <section>
          <h2><a href="http://lua.org">Lua</a></h2>
          <ul>
            <span class="fragment"><li>Lightweight embeddable scripting language</li></span>
            <span class="fragment"><li>Good way of building a mental model of coroutines</li></span>
            <span class="fragment"><li>Single threaded so lock-free, no races etc.</li></span>
            <span class="fragment"><li>Implement your own dispatcher in Lua</li></span>
            <span class="fragment"><li><a href="https://www.lua.org/pil/9.1.html">Lua coroutines</a> are stackful</li></span>
            <span class="fragment"><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">C++20 coroutines</a> are stackless</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://github.com/bluwireless/LuaChat/blob/master/behaviours/lua_chat.lua">LuaChat</a></h2>
            <ul>
              <span class="fragment"><li>Sender coroutine: sends user input to peer</li></span>
              <span class="fragment"><li>Receiver coroutine: prints received messages</li></span>
              <span class="fragment"><li>Dispatcher: schedules sender and receiver</li></span>
              <span class="fragment"><li>main: processes arguments and creates coroutines</li></span>
            </ul>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/echo_server">LuaChat Screen Capture</a></h2>
          <video data-autoplay src="media/luachat-terminal-capture-1080.mov"></video>
        </section>

        <section>
            <h2>Sender Coroutine</h2>
            <pre class="stretch"><code class="lua" data-trim data-line-numbers="">
-- Connect to the peer and send messages read from stdin
function sender (host, port)

  while true do

    local remote, err = socket.connect(host, port)
    while not remote do
      coroutine.yield()

      remote, err = socket.connect(host, port)
    end

    print("Connected to " .. host .. ":" .. port)

    while err ~= "closed" do
      -- Read from stdin (non-blocking - 1s timeout)
      local ret = require "posix".rpoll(0, 1000)
      if (ret == 1) then
        local message = io.read()
        if (message ~= "") then
          _, err = remote:send(message .. "\n")
        end
      else -- read timeout: update connection status
        _, err = remote:send("\0")
      end

      coroutine.yield()
    end
  end
end
            </code></pre>
          </section>

        <section>
            <h2>Receiver Coroutine</h2>
            <pre class="stretch"><code class="lua" data-trim data-line-numbers="">
-- Receive messages from our peer and print them
function receiver (port)

  local server = assert(socket.bind("*", port))
  server:settimeout(0.1) -- set non-blocking (100 ms timeout)

  while true do

    local _, port = server:getsockname()
    print("Waiting for connection on port " .. port);

    local client, err = server:accept()
    if (not client and err == "timeout") then
      coroutine.yield()
    else
      local peer_ip, peer_port = client:getpeername()

      client:send("Connected to LuaChat!\n")
      client:settimeout(0.1)

      while err ~= "closed" do
        local line
        line, err = client:receive("*l")

        if not err then
          print(
            string.format("%s:%d> %s", peer_ip, peer_port, line)
          )
        else
          coroutine.yield()
        end
      end
    end
  end
end
            </code></pre>
          </section>

          <section>
            <h2><a href="https://www.lua.org/pil/9.4.html">Dispatcher</a></h2>
            <pre class="stretch"><code class="lua" style="width:102%" data-trim data-line-numbers="">
function dispatcher (coroutines)

  while true do
    if next(coroutines) == nil then break end -- no more coroutines

    for name, co in pairs(coroutines) do
      local status, res = coroutine.resume(co)

      if res then -- coroutine has returned a result (i.e. finished)
        if type(res) == "string" then -- runtime error
          print("Lua coroutine '" .. name ..
                "' has exited with error: " .. res)
        else
          print("Lua coroutine '" .. name .. "' exited")
        end

        coroutines[name] = nil
      end
    end
  end
end
            </code></pre>
          </section>

          <section>
            <h2>Main Code</h2>
            <pre class="stretch"><code class="lua" style="width:102%" data-trim data-line-numbers="">
local port, remote_ip, remote_port = tonumber(arg[1]),
                                     arg[2],
                                     tonumber(arg[3])

print(
  string.format("Starting LuaChat:\n" ..
                "  local port: %d\n" ..
                "  remote IP: %s\n" ..
                "  remote port: %d\n\n", port, remote_ip, remote_port)
)

-- Create co-routines
local coroutines = {}
coroutines["receiver"] = coroutine.create(receiver)
coroutine.resume(coroutines["receiver"], port)

coroutines["sender"] = coroutine.create(sender)
coroutine.resume(coroutines["sender"], remote_ip, remote_port)

-- Run the main loop
dispatcher(coroutines)
            </code></pre>
          </section>

        </section>
        <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Coroutine Types</h1>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaitable Type</a></h2>
          <ul>
            <span class="fragment"><li>Supports the <code>co_await</code> operator</li></span>
            <span class="fragment"><li>Controls the semantics of an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">await-expression</a></li></span>
            <span class="fragment"><li>Informs the compiler how to obtain the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaiter</a></li></span>
          </ul>

          <span class="fragment"><pre><code class="c++" data-trim data-line-numbers="">
co_await async_write(..., use_awaitable);
          </span></code></pre>

        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaiter Type</a></h2>
          <ul>
            <span class="fragment"><li>Defines suspend and resume behaviour</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_ready</a></code>: is suspend required?</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_suspend</a></code>: schedule resume</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_resume</a></code>: <code>co_await</code> return result</li><p></span>
            <span class="fragment"><li>Can be the same as the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaitable type</a></li></span>
            <span class="fragment"><li>... though not neccesarily</li></span>
          </ul>
        </section>

        <section>
          <h2>Coroutine Return Type</h2>
          <ul>
            <span class="fragment"><li>Declares the promise type to the compiler</li></span>
            <span class="fragment"><ul><li>... using <code>coroutine_traits</code></li></ul></span>
            <span class="fragment"><li>E.g. '<code>task&ltT&gt</code>' or '<code>generator&ltT&gt</code>'</li></span>
            <span class="fragment"><li><a href="https://github.com/lewissbaker/cppcoro">CppCoro</a> defines several return types</li></span>
            <span class="fragment"><li>Sometimes referred to as a 'future'</li></span>
            <span class="fragment"><ul><li>Not to be confused with <code>std::future</code></li></ul></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Promise Type</a></h2>
          <ul>
            <span class="fragment"><li>Controls the coroutine's behaviour</li></span>
            <span class="fragment"><ul><li>... example coming up</li></ul></span>
            <span class="fragment"><li>Implements methods that are called at specific points during the execution of the coroutine</li></span>
            <span class="fragment"><li>Conveys coroutine result (or exception)</li></span>
            <span class="fragment"><li>Again - not to be confused with <code>std::promise</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Customising Co_Await</a></h2>
          <ul>
            <span class="fragment"><li>The <code>await_transform</code> method:</li></span>
            <span class="fragment"><ul><li>Defined in the <code>promise_type</code></li></ul></span>
            <span class="fragment"><ul><li>Enables types that are not awaitable</li></ul></span>
            <span class="fragment"><ul><li>Disables <code>co_await</code> on certain types</li></ul></span>
            <span class="fragment"><ul><li>Modify the behaviour of awaitable values</li></ul></span>
            <span class="fragment"><li>Also possible to customise <code>co_yield</code></li></span>
            <span class="fragment"><li>See Lewis Baker's Excellent <a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Blog Post</a> for details</li></span>
          </ul>
        </section>

        <section>
          <h2><a href=""><code>coroutine_handle</code></a></h2>
          <ul>
            <span class="fragment"><li>Points to a coroutine frame on the heap</li></span>
            <span class="fragment"><ul><li>can be allocated on the stack</li></ul></span>
            <span class="fragment"><li>Coroutine frames contain volatile state</li></span>
            <span class="fragment"><ul><li>the address to resume at, local variables etc.</li></ul></span>
            <span class="fragment"><li>Non-owning - has to be explicitly destroyed</li></span>
            <span class="fragment"><ul><li>... typically through RAII</li></ul></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/tree/master/generator">Generator Example</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="|77-82|61-75|74|61|62-71|74|15|16-17|19-40|22-24|26-27|29-32|36-39|42-58|">
//
// card_dealer.cpp
// ---------------
//

#include &ltcoroutine&gt
#include &ltarray&gt
#include &ltrandom&gt
#include &ltstring&gt

#include &ltiostream&gt

template &lttypename T&gt struct generator {
  struct promise_type;
  using coroutine_handle = std::coroutine_handle&ltpromise_type&gt;

  struct promise_type {
    T current_value;

    auto get_return_object() {
      return generator{coroutine_handle::from_promise(*this)};
    }

    // Start 'lazily' i.e. suspend ('eagerly' == 'suspend_never').
    auto initial_suspend() { return std::suspend_always{}; }

    // Opportunity to publish results, signal completion etc.
    // Suspend so that destroy() is called via RAII from outside
    // the coroutine.
    auto final_suspend() noexcept { return std::suspend_always{}; }

    void unhandled_exception() { std::terminate(); }

    auto yield_value(T const &value) {
      current_value = value;
      return std::suspend_always{};
    }
  };

  bool next() {
    return coroutine ? (coroutine.resume(), !coroutine.done())
                     : false;
  }

  T value() const { return coroutine.promise().current_value; }

  // Range support, class design etc.

  ~generator() {
    if (coroutine)
      coroutine.destroy();
  }

private:
  generator(coroutine_handle h) : coroutine(h) {}
  coroutine_handle coroutine;
};

generator&ltstd::string&gt card_dealer(int deck_size) {
  std::default_random_engine rng;
  std::uniform_int_distribution&ltint&gt card(0, 12);
  std::uniform_int_distribution&ltint&gt suit(0, 3);

  std::array&ltstd::string, 13&gt cards = {
      "Ace", "2", "3",  "4",    "5",     "6",   "7",
      "8",   "9", "10", "Jack", "Queen", "King"};

  std::array&ltstd::string, 4&gt suits = {"Clubs", "Diamonds",
                                      "Spades", "Hearts"};

  for (int i = 0; i &lt deck_size; i++)
    co_yield(cards[card(rng)] + " of " + suits[suit(rng)]);
}

int main() {
  generator&ltstd::string&gt dealer = card_dealer(100);

  while (dealer.next())
    std::cout &lt&lt dealer.value() &lt&lt std::endl;
}
        </code></pre>
      </section>

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Chat Example</h1>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code.git">Coroutine Chat</a></h2>
          <ul>
            <span class="fragment"><li>Prototyped in Lua - implement in C++20</li></span>
            <span class="fragment"><li>Retain coroutine design:</li></span>
            <span class="fragment"><ul><li>Sender: reads keyboard and sends</li></ul></span>
            <span class="fragment"><ul><li>Receiver: prints messages</li></ul></span>
            <span class="fragment"><ul><li>Dispatcher: Boost IO context</li></ul></span>
            <span class="fragment"><li>Must be non-blocking</li></span>
            <span class="fragment"><li>Users should be able to reconnect</li></span>
          </ul>
        </section>

        <section data-menu-title="Chat Screen Capture">
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/co_chat/co_chat.cpp">Build & Run</a></h2>
          <video data-autoplay src="media/co_chat-terminal-capture-1080.mov"></video>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/co_chat/co_chat.cpp">Chat Class</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="|7-12|14-15|17|">
class chat {

public:
  chat(char *addr, char *port, char *remote_addr,
       char *remote_port) {

    tcp::resolver resolver(ctx);
    basic_resolver_entry<tcp> listen_endpoint;
    basic_resolver_entry<tcp> remote_endpoint;

    listen_endpoint = *resolver.resolve(addr, port, passive);
    remote_endpoint = *resolver.resolve(remote_addr, remote_port);

    co_spawn(ctx, sender(remote_endpoint), detached);
    co_spawn(ctx, receiver(listen_endpoint), detached);

    ctx.run();
  }

private:
  awaitable<void> sender(tcp::endpoint remote) {
    // ...
  }

  awaitable<void> receiver(tcp::endpoint listen) {
    // ,,,
  }

  // Member variables (shared between coroutines)
  io_context ctx;
  bool connected = false;
};
          </code></pre>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/co_chat/co_chat.cpp">Sender Coroutine</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="|3-21|24-39|25-33|35-36|38|">
awaitable&ltvoid&gt sender(tcp::endpoint remote) {

  for (;;) {
    tcp::socket remote_sock(ctx);

    auto [error] = co_await remote_sock.async_connect(
        remote, as_tuple(use_awaitable));
    if (!error) {
      std::cout &lt&lt "Connected to: " &lt&lt remote &lt&lt std::endl;
      connected = true;
    } else {
      std::cout &lt&lt "Could not connect to: " &lt&lt remote
                &lt&lt " - retrying in 1s " &lt&lt std::endl;

      steady_timer timer(
          co_await boost::asio::this_coro::executor);
      timer.expires_after(std::chrono::seconds(1));
      co_await timer.async_wait(use_awaitable);

      continue;
    }

    std::string data;
    while (connected) {
      // Read a string from stdin (non-blocking)
      struct pollfd input[1] = {{.fd = 0, .events = POLLIN}};
      if (poll(input, 1, 100 /* timeout in ms */)) {
        char c;
        while (std::cin.get(c) && c != '\n')
          data += c;

        data += "\r\n";
      }

      co_await async_write(remote_sock, buffer(data),
                           as_tuple(use_awaitable));

      data.clear();
    }
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/co_chat/co_chat.cpp">Receiver Coroutine</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="|6-7|10-25|">
awaitable&ltvoid&gt receiver(tcp::endpoint listen) {

  tcp::acceptor acceptor(ctx, listen);

  for (;;) {
    auto [error, client] =
        co_await acceptor.async_accept(as_tuple(use_awaitable));

    if (!error) {
      std::string data;

      for (;;) {
        auto [error, len] = co_await async_read_until(
            client, dynamic_buffer(data), boost::regex("\r\n"),
            as_tuple(use_awaitable));

        if (error == boost::asio::error::eof) {
          // remote has disconnected
          connected = false;
          break;
        }

        std::cout &lt&lt client.remote_endpoint() &lt&lt "&gt " &lt&lt data;
        data.clear();
      }
    } else {
      std::cerr &lt&lt "Accept failed: " &lt&lt error.message() &lt&lt "\n";
    }
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="https://github.com/jamespascoe/accu2022-example-code/blob/master/co_chat/co_chat.cpp">Complete Listing</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="">
#include &ltboost/asio.hpp&gt
#include &ltboost/asio/experimental/as_tuple.hpp&gt
#include &ltboost/regex.hpp&gt

#include &ltiostream&gt

using boost::asio::awaitable;
using boost::asio::buffer;
using boost::asio::co_spawn;
using boost::asio::detached;
using boost::asio::dynamic_buffer;
using boost::asio::io_context;
using boost::asio::steady_timer;
using boost::asio::use_awaitable;
using boost::asio::experimental::as_tuple;
using boost::asio::ip::basic_resolver_entry;
using boost::asio::ip::tcp;
using boost::asio::ip::tcp::resolver::passive;

using boost::system::error_code;

class chat {

public:
  chat(char *addr, char *port, char *remote_addr,
       char *remote_port) {

    tcp::resolver resolver(ctx);
    basic_resolver_entry&lttcp&gt listen_endpoint;
    basic_resolver_entry&lttcp&gt remote_endpoint;

    listen_endpoint = *resolver.resolve(addr, port, passive);
    remote_endpoint = *resolver.resolve(remote_addr, remote_port);

    co_spawn(ctx, sender(remote_endpoint), detached);
    co_spawn(ctx, receiver(listen_endpoint), detached);

    ctx.run();
  }

private:
  awaitable&ltvoid&gt sender(tcp::endpoint remote) {

    for (;;) {
      tcp::socket remote_sock(ctx);

      auto [error] = co_await remote_sock.async_connect(
          remote, as_tuple(use_awaitable));
      if (!error) {
        std::cout &lt&lt "Connected to: " &lt&lt remote &lt&lt std::endl;
        connected = true;
      } else {
        std::cout &lt&lt "Could not connect to: " &lt&lt remote
                  &lt&lt " - retrying in 1s " &lt&lt std::endl;

        steady_timer timer(
            co_await boost::asio::this_coro::executor);
        timer.expires_after(std::chrono::seconds(1));
        co_await timer.async_wait(use_awaitable);
        continue;
      }

      std::string data;
      while (connected) {
        // Read a string from stdin (non-blocking)
        struct pollfd input[1] = {{.fd = 0, .events = POLLIN}};
        if (poll(input, 1, 100 /* timeout in ms */)) {
          char c;
          while (std::cin.get(c) && c != '\n')
            data += c;

          data += "\r\n";
        }

        co_await async_write(remote_sock, buffer(data),
                             as_tuple(use_awaitable));

        data.clear();
      }
    }
  }

  awaitable&ltvoid&gt receiver(tcp::endpoint listen) {

    tcp::acceptor acceptor(ctx, listen);

    for (;;) {
      auto [error, client] =
          co_await acceptor.async_accept(as_tuple(use_awaitable));

      if (!error) {
        std::string data;

        for (;;) {
          auto [error, len] = co_await async_read_until(
              client, dynamic_buffer(data), boost::regex("\r\n"),
              as_tuple(use_awaitable));

          if (error == boost::asio::error::eof) {
            // remote has disconnected
            connected = false;
            break;
          }

          std::cout &lt&lt client.remote_endpoint() &lt&lt "&gt " &lt&lt data;
          data.clear();
        }
      } else {
        std::cerr &lt&lt "Accept failed: " &lt&lt error.message() &lt&lt "\n";
      }
    }
  }

  // Member variables (shared between coroutines)
  io_context ctx;
  bool connected = false;
};

int main(int argc, char *argv[]) {

  try {
    if (argc != 5) {
      std::cerr &lt&lt "Usage: " &lt&lt argv[0];
      std::cerr &lt&lt " &ltlisten_address&gt &ltlisten_port&gt";
      std::cerr &lt&lt " &ltremote_address&gt &ltremote_port&gt\n";
      return 1;
    }

    chat(argv[1], argv[2], argv[3], argv[4]);

  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt "\n";
  }
}
          </code></pre>
        </section>




<!--

  TODO:

  Replace build lines?

  Enrichment:

  Update Generator Example
  Diagrams? (2 - LucidChart)

-->

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Conclusion</h1>
        </section>

        <section>
          <h2>What's Coming in C++23?</h2>
            <ul>
              <span class="fragment"><li>New Coroutine Types (plus <a href="http://wg21.link/p1745">other</a> improvements)</li></span>
              <span class="fragment"><li><a href="http://wg21.link/p1056"><code>std::lazy<T></code></a>: lazily evaluated task</li></span>
              <span class="fragment"><ul><li>Evolution of <a href="https://github.com/lewissbaker/cppcoro#taskt"><code>cppcoro::task<T></code></a></li></ul></span>
              <span class="fragment"><li><a href="http://wg21.link/p2168"><code>std::generator<T></code></a>: synchronous generator</li></span>
              <span class="fragment"><ul><li>supports ranges and recursion</li></ul></span>
              <span class="fragment"><ul><li>(i.e. yield a generator of the same type)</li></ul></span>
            </ul>
        </section>

        <section>
          <h2>Conclusion</h2>
            <ul>
              <span class="fragment"><li>C++20 coroutines provide a language capability</li></span>
              <span class="fragment"><ul><li>Functions can be suspended and later resumed</li></ul></span>
              <span class="fragment"><li>Coroutines allow asynchronous code to be written</li></span>
              <span class="fragment"><ul><li>With the readability of synchronous code</li></ul></span>
              <span class="fragment"><li>Using coroutines in user-code can seem difficult</li></span>
              <span class="fragment"><ul><li>Library support is improving</li></ul></span>
              <span class="fragment"><ul><li>Persevere with <a href="#/key-references">key references</a></li></ul></span>
            </ul>
        </section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <a href="http://jamespascoe.github.io/accu2022">http://jamespascoe.github.io/accu2022</a><br>
          <a href="https://github.com/jamespascoe/accu2022-example-code.git"><font size="6">https://github.com/jamespascoe/accu2022-example-code.git</font></a>
        </section>

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script src="plugin/animated/revealjs-animated.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 5400,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
        }
      }, false );
   </script>
  </body>
</html>
