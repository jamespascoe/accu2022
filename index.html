<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>How to Use C++20 Coroutines for Networking</title>

    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico?">

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/league.css" id="theme">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/github.css" id="highlight-theme">

  </head>
  <body>
    <div class="reveal">
      <div class="slides">

        <section id="Title-Slide"
                 data-state="hideControls"
                 data-menu-title="Title Slide"
                 data-background-image="media/title-slide.png"
                 data-background-size="contain">
        </section>

        <section data-menu-title="Coroutines for Networking">
          <h2>How to Use C++20 Coroutines<br>for Networking</h2>
          <p>
            <small>
              Jim (James) Pascoe<br>
              <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
              <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

              <a href="http://jamespascoe.github.io/accu2022">http://jamespascoe.github.io/accu2022</a><br>
              <a href="https://github.com/jamespascoe/accu2022-example-code.git">https://github.com/jamespascoe/accu2022-example-code.git</a>
            </small>
        </section>
        <section data-menu-title="Poll: Coroutine Familiarity">
          <h3 style="color:yellow">How Familiar are you with Coroutines?</h3>
            <ol>
              <span class="fragment"><li>I am a coroutine expert</li></span>
              <span class="fragment"><li>I have a strong grasp but need to fill in some details</li></span>
              <span class="fragment"><li>I have some understanding but want to learn more</li></span>
              <span class="fragment"><li>I am just starting to learn about them</li></span>
            </ol>
        </section>
        <section>
          <h2>Overview</h2>
          <span class="fragment" style="color:yellow">Demystify Using C++20 Coroutines for Networking</span><br>
          <span class="fragment" style="color:yellow">Emphasis on practical examples and code</span>
          <p>
          <ul>
            <span class="fragment"><li>Coroutines: fundamentals, benefits and usage</li></span>
            <span class="fragment">
              <ul>
                <li><a href="https://www.lua.org/versions.html#5.4">Lua 5.4.4</a><span class="fragment"> and <a href="https://en.cppreference.com/w/cpp/language/coroutines">C++20</a></span></li>
              </ul>
            </span>
            <span class="fragment"><li>How to Write Networking Code Using Coroutines</li></span>
            <ul>
              <span class="fragment"><li><a href="https://github.com/jamespascoe/CoChat.git">CoChat</a>: a coroutine based chat program</li></span>
              <span class="fragment"><li><a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio/overview/core/cpp20_coroutines.html">Boost Asio (1.78)</a></li></span>
            </ul>
            <span class="fragment"><li>C++23: the future of Coroutines</li></span>
          </ul>
        </section>

      <section>
        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Fundamentals</h1>
        </section>

        <section>
          <h2>Coroutines</h2>
          <span class="fragment" style="color:yellow">Coroutines are subroutines </span>
          <span class="fragment" style="color:yellow">with enhanced semantics</span><p>
          <ul>
            <span class="fragment"><li>Invoked by a caller </span>
            <span class="fragment">(and return to a caller) ...</li></span>
            <span class="fragment"><li>Can suspend execution (returns to the caller)</li></span>
            <span class="fragment"><li>Can resume execution (at a later time)</li></span>
          </ul>
        </section>

        <section>
          <h2>Benefits</h2>
          <span class="fragment" style="color:yellow">Write asynchronous code ...</span><br>
          <span class="fragment" style="color:yellow">with the readability of synchronous code</span><p>
          <ul>
            <span class="fragment"><li>Useful for networking</li></span>
            <span class="fragment"><li>Lots of blocking operations (connect, send, receive)</li></span>
            <span class="fragment"><li>Multi-threading (send and receive threads)</li></span>
            <span class="fragment"><li>Asynchronous operations mean callbacks</li></span>
            <span class="fragment"><li>Control flow fragments</li></span>
          </ul>
        </section>

        <!-- TODO: Code build / run / test instructions
        <section>
          <video data-autoplay src="media/terminal-window.mp4"></video>
        </section>
        -->

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Blocking Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|21|23|25-40|">
//
// echo_server_blocking.cpp
// ------------------------
//
// g++-11 -I/usr/local/boost_1_78_0/include -Wall -Werror
// echo_server_blocking.cpp -o blocking -l pthread
//

#include &ltboost/asio.hpp&gt
#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::io_context;
using boost::asio::ip::tcp;
using boost::system::error_code;

static const int buf_len = 1000;

int main() {
  try {
    io_context ctx;

    tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

    for (;;) {
      tcp::socket peer_socket(ctx);
      acceptor.accept(peer_socket);

      std::array&ltchar, buf_len&gt buf;

      for (;;) {
        error_code error;
        std::size_t len =
            peer_socket.read_some(buffer(buf), error);
        if (error == boost::asio::error::eof)
          break;

        write(peer_socket, buffer(buf, len));
      }
    }
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt "\n";
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Asynchronous Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|89-105|96-98|101|72-87|47-70|31-45|">
//
// echo_server_async.cpp
// ---------------------
//
// g++-11 -I/usr/local/boost_1_78_0/include -fcoroutines -std=c++20
// -Wall -Werror echo_server_async.cpp -o async -l pthread
//

#include &ltboost/asio.hpp&gt

#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::io_context;
using boost::asio::ip::tcp;
using boost::system::error_code;

static const int buf_len = 1000;

void accept_handler(error_code const &error,
                    tcp::socket &peer_socket,
                    std::array&ltchar, buf_len&gt &buf,
                    tcp::acceptor &acceptor);

void read_handler(error_code const &error,
                  std::size_t bytes_transferred,
                  tcp::socket &peer_socket,
                  std::array&ltchar, buf_len&gt &buf,
                  tcp::acceptor &acceptor);

void write_handler(error_code const &error, std::size_t length,
                   tcp::socket &peer_socket,
                   std::array&ltchar, buf_len&gt &buf,
                   tcp::acceptor &acceptor) {
  if (!error) {
    peer_socket.async_read_some(
        buffer(buf, length), [&](error_code const &error,
                                 std::size_t bytes_transferred) {
          read_handler(error, bytes_transferred, peer_socket, buf,
                       acceptor);
        });
  } else
    std::cerr &lt&lt "Write handler error: " &lt&lt error.message()
              &lt&lt std::endl;
}

void read_handler(error_code const &error,
                  std::size_t bytes_transferred,
                  tcp::socket &peer_socket,
                  std::array&ltchar, buf_len&gt &buf,
                  tcp::acceptor &acceptor) {
  if (!error) {
    async_write(peer_socket, buffer(buf, bytes_transferred),
                [&](error_code const &error, std::size_t length) {
                  write_handler(error, length, peer_socket, buf,
                                acceptor);
                });
  } else {
    if (error == boost::asio::error::eof) {
      peer_socket.close();

      acceptor.async_accept(
          peer_socket, [&](error_code const &error) {
            accept_handler(error, peer_socket, buf, acceptor);
          });
    } else
      std::cerr &lt&lt "Read handler error: " &lt&lt error.message()
                &lt&lt std::endl;
  }
}

void accept_handler(error_code const &error,
                    tcp::socket &peer_socket,
                    std::array&ltchar, buf_len&gt &buf,
                    tcp::acceptor &acceptor) {

  if (!error) {
    peer_socket.async_read_some(
        buffer(buf, buf_len), [&](error_code const &error,
                                  std::size_t bytes_transferred) {
          read_handler(error, bytes_transferred, peer_socket, buf,
                       acceptor);
        });
  } else
    std::cerr &lt&lt "Accept handler error: " &lt&lt error.message()
              &lt&lt std::endl;
}

int main() {
  io_context ctx;
  tcp::socket peer_socket(ctx);
  tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

  std::array&ltchar, buf_len&gt buf;

  acceptor.async_accept(peer_socket, [&](error_code const &error) {
    accept_handler(error, peer_socket, buf, acceptor);
  });

  try {
    ctx.run();
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt "\n";
  }
}
          </code></pre>
        </section>

        <section>
          <h2><a href="http://www.lua.org/manual/5.4/manual.html#4">Coroutine Echo Server</a></h2>
            <pre class="stretch"><code class="c++" style="width:102%" data-trim data-line-numbers="|43-57|50-51|53|22-41|27|30-31|35-36|">
//
// echo_server_coroutine.cpp
// -------------------------
//
// g++-11 -I/usr/local/boost_1_78_0/include -fcoroutines -std=c++20
// -Wall -Werror echo_server_coroutine.cpp -o coroutine -l pthread
//

#include &ltboost/asio.hpp&gt
#include &ltboost/asio/experimental/as_tuple.hpp&gt

#include &ltiostream&gt

using boost::asio::buffer;
using boost::asio::detached;
using boost::asio::io_context;
using boost::asio::use_awaitable;
using boost::asio::experimental::as_tuple;
using boost::asio::ip::tcp;
using boost::system::error_code;

boost::asio::awaitable&ltvoid&gt echo(tcp::socket peer_socket,
                                  tcp::acceptor acceptor) {
  std::array&ltchar, 1000&gt buf;

  for (;;) {
    co_await acceptor.async_accept(peer_socket, use_awaitable);

    for (;;) {
      auto [error, len] = co_await peer_socket.async_read_some(
          buffer(buf), as_tuple(use_awaitable));
      if (error == boost::asio::error::eof)
        break;

      co_await async_write(peer_socket, buffer(buf, len),
                           use_awaitable);
    }

    peer_socket.close();
  }
}

int main() {
  try {
    io_context ctx;

    tcp::socket socket(ctx);
    tcp::acceptor acceptor(ctx, tcp::endpoint(tcp::v4(), 6666));

    co_spawn(ctx, echo(std::move(socket), std::move(acceptor)),
             detached);

    ctx.run();
  } catch (std::exception &e) {
    std::cerr &lt&lt "Exception: " &lt&lt e.what() &lt&lt std::endl;
  }
}
          </code></pre>
        </section>

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>C++20 Coroutines</h1>
        </section>

        <section data-menu-title="Coroutines in C++20">
          <h2><a href="https://en.cppreference.com/w/cpp/language/coroutines">Coroutine Support in C++20</a></h2>
            <ul>
              <span class="fragment"><li>Three new keywords: <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a>, <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a></li></span>
              <span class="fragment"><li>New types:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle"><code>coroutine_handle&ltP&gt</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits"><code>coroutine_traits&ltTs...&gt</code></a></li></span>
              </ul>
              <span class="fragment"><li>Trivial awaitables:</li></span>
              <ul>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_always"><code>std::suspend_always</code></a></li></span>
                <span class="fragment"><li><a href="https://en.cppreference.com/w/cpp/coroutine/suspend_never"><code>std::suspend_never</code></a></li></span>
              </ul>
            </ul>
        </section>

        <section>
          <h2>Tips for Learning</h2>
            <ul>
              <span class="fragment"><li>Principally for library development (not user-code)</li></span>
              <span class="fragment"><li>Libraries with coroutine support:</li></span>
              <ul>
                <span class="fragment"><li>Boost Asio:</li>
                  <ul>
                    <li>(first in <a href="https://www.boost.org/doc/libs/1_67_0/doc/html/boost_asio/overview/core/coroutines_ts.html">1.67.0</a>, 'C++20 Support' in <a href="https://www.boost.org/doc/libs/1_77_0/doc/html/boost_asio/overview/core/cpp20_coroutines.html">1.77.0</a>)</li>
                  </ul>
                </span>
                <span class="fragment"><li>Lewis Baker's <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a></li></span>
              </ul>
              <span class="fragment"><li><span style="color:yellow">References to 'promise' and 'future' are not <code>std::promise</code> and <code>std::future</code>!</span></li></span>
            </ul>
        </section>

        <section>
          <h2>Key References</h2>
            <ul>
              <span class="fragment"><li><a href="https://lewissbaker.github.io/">Lewis Baker:</a></li></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine Theory</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Understanding operator co_await</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Understanding the promise type</a></li></ul></span>
              <span class="fragment"><ul><li><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer">Understanding Symmetric Transfer</a></li></ul></span>
              <span class="fragment"><li><a href="https://www.scs.stanford.edu/~dm">Dave Mazière:</a></li></span>
              <span class="fragment"><ul><li><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">My tutorial and take on C++20 coroutines</a></li></ul></span>
              <span class="fragment"><li><a href="https://wg21.link/n4775">Gor Nishanov:</a></li></span>
              <span class="fragment"><ul><li><a href="https://wg21.link/n4775">C++ Extensions for Coroutines (N4775)</a></li></ul></span>
            </ul>
        </section>

        <section>
          <h2>Tutorial Overview</h2>
            <ul>
              <span class="fragment"><li>Goal: implement a 'chat' program using coroutines</li></span>
              <span class="fragment"><li>Prototype in <a href="https://www.lua.org/pil/9.1.html">Lua 5.4.4</a></li></span>
              <span class="fragment"><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">C++20</a> coroutines:</li></span>
              <ul>
                <span class="fragment">
                  <li>
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_await">co_await</a>,
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_yield">co_yield</a> and
                    <a href="https://en.cppreference.com/w/cpp/language/coroutines#co_return">co_return</a>
                  </li>
                </span>
                <span class="fragment"><li>Return objects, promises, awaitables and traits</li></span>
              </ul>
              <span class="fragment"><li>Implement 'chat' in C++ (using <a href="https://www.boost.org/doc/libs/1_78_0/doc/html/boost_asio.html">Boost Asio 1.78</a>)</li></span>
            </ul>
        </section>

        <section>
          <h2><a href="http://lua.org">Lua</a></h2>
          <ul>
            <span class="fragment"><li>Lightweight embeddable scripting language</li></span>
            <span class="fragment"><li>Good way of building a mental model of coroutines</li></span>
            <span class="fragment"><li>Single threaded so lock-free, no races etc.</li></span>
            <span class="fragment"><li>Implement your own dispatcher in Lua</li></span>
            <span class="fragment"><li><a href="https://www.lua.org/pil/9.1.html">Lua coroutines</a> are stackful</li></span>
            <span class="fragment"><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">C++20 coroutines</a> are stackless</li></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://github.com/bluwireless/LuaChat/blob/master/behaviours/lua_chat.lua">LuaChat</a></h2>
            <ul>
              <span class="fragment"><li>Sender coroutine: sends user input to peer</li></span>
              <span class="fragment"><li>Receiver coroutine: prints received messages</li></span>
              <span class="fragment"><li>Dispatcher coroutine: schedules sender and receiver</li></span>
              <span class="fragment"><li>main: processes arguments and creates coroutines</li></span>
            </ul>
        </section>

        <!-- TODO: Code build / run / test instructions
        <section>
          <video data-autoplay src="media/terminal-test.mov"></video>
        </section>
        -->

        <section>
            <h2>Sender Coroutine</h2>
            <pre class="stretch"><code class="lua" data-trim data-line-numbers="">
-- Connect to the peer and send messages read from stdin
function sender (host, port)

  while true do

    local remote, err = socket.connect(host, port)
    while not remote do
      coroutine.yield()

      remote, err = socket.connect(host, port)
    end

    print("Connected to " .. host .. ":" .. port)

    while err ~= "closed" do
      -- Read from stdin (non-blocking - 1s timeout)
      local ret = require "posix".rpoll(0, 1000)
      if (ret == 1) then
        local message = io.read()
        if (message ~= "") then
          _, err = remote:send(message .. "\n")
        end
      else -- read timeout: update connection status
        _, err = remote:send("\0")
      end

      coroutine.yield()
    end
  end
end
            </code></pre>
          </section>

        <section>
            <h2>Receiver Coroutine</h2>
            <pre class="stretch"><code class="lua" data-trim data-line-numbers="">
-- Receive messages from our peer and print them
function receiver (port)

  local server = assert(socket.bind("*", port))
  server:settimeout(0.1) -- set non-blocking (100 ms timeout)

  while true do

    local _, port = server:getsockname()
    print("Waiting for connection on port " .. port);

    local client, err = server:accept()
    if (not client and err == "timeout") then
      coroutine.yield()
    else
      local peer_ip, peer_port = client:getpeername()

      client:send("Connected to LuaChat!\n")
      client:settimeout(0.1)

      while err ~= "closed" do
        local line
        line, err = client:receive("*l")

        if not err then
          print(
            string.format("%s:%d> %s", peer_ip, peer_port, line)
          )
        else
          coroutine.yield()
        end
      end
    end
  end
end
            </code></pre>
          </section>

          <section>
            <h2><a href="https://www.lua.org/pil/9.4.html">Dispatcher</a></h2>
            <pre class="stretch"><code class="lua" style="width:102%" data-trim data-line-numbers="">
function dispatcher (coroutines)

  while true do
    if next(coroutines) == nil then break end -- no more coroutines

    for name, co in pairs(coroutines) do
      local status, res = coroutine.resume(co)

      if res then -- coroutine has returned a result (i.e. finished)
        if type(res) == "string" then -- runtime error
          print("Lua coroutine '" .. name ..
                "' has exited with error: " .. res)
        else
          print("Lua coroutine '" .. name .. "' exited")
        end

        coroutines[name] = nil
      end
    end
  end
end
            </code></pre>
          </section>

          <section>
            <h2>Main Code</h2>
            <pre class="stretch"><code class="lua" style="width:102%" data-trim data-line-numbers="">
local port, remote_ip, remote_port = tonumber(arg[1]),
                                     arg[2],
                                     tonumber(arg[3])

print(
  string.format("Starting LuaChat:\n" ..
                "  local port: %d\n" ..
                "  remote IP: %s\n" ..
                "  remote port: %d\n\n", port, remote_ip, remote_port)
)

-- Create co-routines
local coroutines = {}
coroutines["receiver"] = coroutine.create(receiver)
coroutine.resume(coroutines["receiver"], port)

coroutines["sender"] = coroutine.create(sender)
coroutine.resume(coroutines["sender"], remote_ip, remote_port)

-- Run the main loop
dispatcher(coroutines)
            </code></pre>
          </section>

        </section>
        <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Supporting Types</h1>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaitable Type</a></h2>
          <ul>
            <span class="fragment"><li>Supports the <code>co_await</code> operator</li></span>
            <span class="fragment"><li>Controls the semantics of an <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">await-expression</a></li></span>
            <span class="fragment"><li>Informs the compiler how to obtain the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaiter</a></li></span>
          </ul>

          <span class="fragment"><pre><code class="c++" data-trim data-line-numbers="">
co_await async_write(..., use_awaitable);
          </span></code></pre>

        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">Awaiter Type</a></h2>
          <ul>
            <span class="fragment"><li>Defines suspend and resume behaviour</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_ready</a></code>: is suspend required?</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_suspend</a></code>: schedule resume</li></span>
            <span class="fragment"><li><code><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">await_resume</a></code>: <code>co_await</code> return result</li><p></span>
            <span class="fragment"><li>Can be the same as the <a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await">awaitable type</a></li></span>
            <span class="fragment"><li>... though not neccesarily</li></span>
          </ul>
        </section>

        <section>
          <h2>Coroutine Return Type</h2>
          <ul>
            <span class="fragment"><li>Declares the promise type to the compiler</li></span>
            <span class="fragment"><ul><li>... using <code>coroutine_traits</code></li></ul></span>
            <span class="fragment"><li>E.g. '<code>task&ltT&gt</code>' or '<code>generator&ltT&gt</code>'</li></span>
            <span class="fragment"><li><a href="https://github.com/lewissbaker/cppcoro">CppCoro</a> defines several return types</li></span>
            <span class="fragment"><li>Sometimes referred to as a 'future'</li></span>
            <span class="fragment"><ul><li>Not to be confused with <code>std::future</code></li></ul></span>
          </ul>
        </section>

        <section>
          <h2><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type">Promise Type</a></h2>
          <ul>
            <span class="fragment"><li>Controls the coroutine's behaviour</li></span>
            <span class="fragment"><ul><li>... example coming up</li></ul></span>
            <span class="fragment"><li>Implements methods that are called at specific points during the execution of the coroutine</li></span>
            <span class="fragment"><li>Conveys coroutine result (or exception)</li></span>
            <span class="fragment"><li>Again - not to be confused with <code>std::promise</code></li></span>
          </ul>
        </section>

        <section>
          <h2><a href=""><code>coroutine_handle</code></a></h2>
          <ul>
            <span class="fragment"><li>Points to a coroutine frame on the heap</li></span>
            <span class="fragment"><ul><li>can be allocated on the stack</li></ul></span>
            <span class="fragment"><li>Coroutine frames contain volatile state</li></span>
            <span class="fragment"><ul><li>the address to resume at, local variables etc.</li></ul></span>
            <span class="fragment"><li>Non-owning - has to be explicitly destroyed</li></span>
            <span class="fragment"><ul><li>... typically through RAII</li></ul></span>
          </ul>
        </section>

      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Example</h1>
        </section>

        <section>
          <h2><a href="">Generator Example</a></h2>
          <pre class="stretch"><code class="c++" data-trim data-line-numbers="|77-82|61-75|74|61|62-71|74|15|16-17|19-40|22-24|26-27|29-32|36-39|42-58|">
//
// card_dealer.cpp
// ---------------
//
// g++-11 -fcoroutines -Wall -Werror card_dealer.cpp -o dealer
//

#include &ltcoroutine&gt
#include &ltarray&gt
#include &ltrandom&gt
#include &ltstring&gt

#include &ltiostream&gt

template &lttypename T&gt struct generator {
  struct promise_type;
  using coroutine_handle = std::coroutine_handle&ltpromise_type&gt;

  struct promise_type {
    T current_value;

    auto get_return_object() {
      return generator{coroutine_handle::from_promise(*this)};
    }

    // Start 'lazily' i.e. suspend ('eagerly' == 'suspend_never').
    auto initial_suspend() { return std::suspend_always{}; }

    // Opportunity to publish results, signal completion etc.
    // Suspend so that destroy() is called via RAII from outside
    // the coroutine.
    auto final_suspend() noexcept { return std::suspend_always{}; }

    void unhandled_exception() { std::terminate(); }

    auto yield_value(T const &value) {
      current_value = value;
      return std::suspend_always{};
    }
  };

  bool next() {
    return coroutine ? (coroutine.resume(), !coroutine.done())
                     : false;
  }

  T value() const { return coroutine.promise().current_value; }

  // Range support, class design etc.

  ~generator() {
    if (coroutine)
      coroutine.destroy();
  }

private:
  generator(coroutine_handle h) : coroutine(h) {}
  coroutine_handle coroutine;
};

generator&ltstd::string&gt card_dealer(int deck_size) {
  std::default_random_engine rng;
  std::uniform_int_distribution&ltint&gt card(0, 12);
  std::uniform_int_distribution&ltint&gt suit(0, 3);

  std::array&ltstd::string, 13&gt cards = {
      "Ace", "2", "3",  "4",    "5",     "6",   "7",
      "8",   "9", "10", "Jack", "Queen", "King"};

  std::array&ltstd::string, 4&gt suits = {"Clubs", "Diamonds",
                                      "Spades", "Hearts"};

  for (int i = 0; i &lt deck_size; i++)
    co_yield(cards[card(rng)] + " of " + suits[suit(rng)]);
}

int main() {
  generator&ltstd::string&gt dealer = card_dealer(100);

  while (dealer.next())
    std::cout &lt&lt dealer.value() &lt&lt std::endl;
}
        </code></pre>
      </section>









      </section>
      <section>

        <section data-background-video="media/BWT_Intermission.mp4" data-background-video-loop=true>
          <h1>Conclusion</h1>
        </section>

        <section>
          <h2>Performance Advice</h2>
            <ul>
              <span class="fragment" style="color:yellow"><li>Sol3 is fast but you can go faster</li></span>
              <ul>
                <span class="fragment"><li>lots of good advice <a href="https://sol2.readthedocs.io/en/latest/performance.html">here</a></li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li>MCM spends a lot of time in the SWIG wrapper</li></span>
              <ul>
                <span class="fragment"><li>prefer lightweight typemaps</li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li>The partition between C++ and Lua is important</li></span>
              <ul>
                <span class="fragment"><li>as is the concurrency design</li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li>How the code interacts with Lua is significant</li></span>
              <ul>
                <span class="fragment"><li>prefer pre-compiled long-lived behaviours</li></span>
              </ul>
            </ul>
        </section>

        <section>
          <h2>Conclusion</h2>
            <ul>
              <span class="fragment" style="color:yellow"><li>The combination of C++ and Lua is powerful</li></span>
              <ul>
                <span class="fragment"><li>Actions (C++) and Behaviours (Lua)</li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li>Sol3 binds Modern C++ to Lua</li></span>
              <ul>
                <span class="fragment"><li>simple-to-use, fast, ideal for Modern C++</li></span>
                <span class="fragment"><li>by definition is a C++ to Lua binding</li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li>SWIG allows us to map C++ types to/from Lua</li></span>
              <ul>
                <span class="fragment"><li>generates bindings in many languages</li></span>
                <span class="fragment"><li>be mindful of performance</li></span>
              </ul>
              <span class="fragment" style="color:yellow"><li><a href="https://www.lua.org/versions.html#5.4">Lua 5.4.2</a> is now available</li></span>
              <ul>
                <span class="fragment"><li><a href="https://foicica.com/lua/">Lua Quick Reference</a> (updated for Lua 5.4)</li></span>
              </ul>
            </ul>
        </section>

        <section>
          <h2>Questions?</h2>
          <p><p>
          <a href="http://www.james-pascoe.com">http://www.james-pascoe.com</a><br>
          <a href="mailto:james@james-pascoe.com">james@james-pascoe.com</a><p>

          <a href="http://jamespascoe.github.io/accu2022">http://jamespascoe.github.io/accu2022</a><br>
          <a href="https://github.com/jamespascoe/accu2022-example-code.git">https://github.com/jamespascoe/accu2022-example-code.git</a>
        </section>

        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/chart/Chart.min.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script src="plugin/animated/revealjs-animated.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        controls: true,
        totalTime: 5400,
        hideInactiveCursor: true,
        hideCursorTime: 2000,
        hideAddressBar: true,
        preloadIframes: true,
        progress: false,
        touch: true,
        keyboard: {
          67: () => { /* Keycode for the letter 'c' i.e. 'controls' */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundElement.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Toggle video controls on/off */
              currentVideo.controls = !currentVideo.controls
            }
          },
          32: () => { /* Keycode for spacebar */
            var currentSlide = Reveal.getCurrentSlide();
            var currentVideo = currentSlide.slideBackgroundElement.getElementsByTagName('video')[0];
            if (currentVideo) {
              /* Pause/resume video when the spacebar is pressed */
              if (currentVideo.paused == true) currentVideo.play();
              else currentVideo.pause();
            }
            else {
              /* Advance to next slide if no video (default Reveal behaviour) */
              Reveal.next();
            }
          }
        },
        chart: {
          defaults: {
            global: {
              title: { fontColor: "#FFF" },
              legend: {
                position: "bottom",
                labels: { fontColor: "#FFF" },
              },
              tooltips: {
                labels: { fontColor: "#FFF" },
              },
            },
            scale: {
              scaleLabel: { fontColor: "#FFF" },
              gridLines: { color: "#FFF", zeroLineColor: "#FFF" },
              ticks: { fontColor: "#FFF" },
            }
          },
          bar: { backgroundColor: [ "rgba(20,220,220,.8)" , "rgba(220,120,120,.8)", "rgba(20,120,220,.8)", "rgba(255, 159, 64, .8)","rgba(255, 205, 86, .8)", "rgba(153, 102, 255, .8)" ]},
        },
        menu: {
          themes: true,
          delayInit: true
        },
        pdfSeparateFragments: false,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu, RevealChart ]
      });

      Reveal.addEventListener('hideControls', function() {
        Reveal.configure({controls: false});
      }, false );

      Reveal.addEventListener('slidechanged', function() {
        /* Ensure that the Reveal controls and Menu are available on
         * all slides other than the 'Title-Slide'.
         */
        slide_id = Reveal.getCurrentSlide().getAttribute("id");

        if (slide_id !== "Title-Slide") {
          config = Reveal.getConfig();
          if (config["controls"] !== true) {
            Reveal.configure({controls: true});
          }

          menu = Reveal.getPlugin("menu");
          if (!menu.isMenuInitialised()) {
            menu.initialiseMenu();
          }
        }
      }, false );
   </script>
  </body>
</html>
